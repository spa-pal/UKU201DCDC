


#include "uart1.h"
#include <stm32f10x_conf.h>
#include <stm32f10x_lib.h>
#include "modbus.h" 
#include "main.h"
#include "STM32_Reg.h"

#define __HSE                      10000000
#define __PLLMULL					6
#define __SYSCLK  ((__HSE >> 0) * __PLLMULL)
#define __HCLK        (__SYSCLK)
#define __PCLK2       (__HCLK)
#define __DIV(__PCLK, __BAUD)       ((__PCLK*25)/(4*__BAUD))
#define __DIVMANT(__PCLK, __BAUD)   (__DIV(__PCLK, __BAUD)/100)
#define __DIVFRAQ(__PCLK, __BAUD)   (((__DIV(__PCLK, __BAUD) - (__DIVMANT(__PCLK, __BAUD) * 100)) * 16 + 50) / 100)
#define __USART_BRR(__PCLK, __BAUD) ((__DIVMANT(__PCLK, __BAUD) << 4)|(__DIVFRAQ(__PCLK, __BAUD) & 0x0F))

//***********************************************
//сюпр1
char bRXIN1;
char UIB1[100];
//char UOB1[100];
char flag1;
char tx_buffer1[TX_BUFFER_SIZE1];
//char rx_buffer1[RX_BUFFER_SIZE1];

unsigned short rx_wr_index1,rx_rd_index1,rx_counter1;
unsigned short tx_wr_index1,tx_rd_index1,tx_counter1;
char rx_buffer_overflow1;
char tx1_restart;
bool bTRANSMIT1=FALSE;

const char Table87[]={
0x00, 0x0E, 0x1C, 0x12, 0x38, 0x36, 0x24, 0x2A, 0x70, 0x7E, 0x6C, 0x62, 0x48, 0x46, 0x54, 0x5A,
0xE0, 0xEE, 0xFC, 0xF2, 0xD8, 0xD6, 0xC4, 0xCA, 0x90, 0x9E, 0x8C, 0x82, 0xA8, 0xA6, 0xB4, 0xBA,
0xCE, 0xC0, 0xD2, 0xDC, 0xF6, 0xF8, 0xEA, 0xE4, 0xBE, 0xB0, 0xA2, 0xAC, 0x86, 0x88, 0x9A, 0x94,
0x2E, 0x20, 0x32, 0x3C, 0x16, 0x18, 0x0A, 0x04, 0x5E, 0x50, 0x42, 0x4C, 0x66, 0x68, 0x7A, 0x74,
0x92, 0x9C, 0x8E, 0x80, 0xAA, 0xA4, 0xB6, 0xB8, 0xE2, 0xEC, 0xFE, 0xF0, 0xDA, 0xD4, 0xC6, 0xC8,
0x72, 0x7C, 0x6E, 0x60, 0x4A, 0x44, 0x56, 0x58, 0x02, 0x0C, 0x1E, 0x10, 0x3A, 0x34, 0x26, 0x28,
0x5C, 0x52, 0x40, 0x4E, 0x64, 0x6A, 0x78, 0x76, 0x2C, 0x22, 0x30, 0x3E, 0x14, 0x1A, 0x08, 0x06,
0xBC, 0xB2, 0xA0, 0xAE, 0x84, 0x8A, 0x98, 0x96, 0xCC, 0xC2, 0xD0, 0xDE, 0xF4, 0xFA, 0xE8, 0xE6,
0x2A, 0x24, 0x36, 0x38, 0x12, 0x1C, 0x0E, 0x00, 0x5A, 0x54, 0x46, 0x48, 0x62, 0x6C, 0x7E, 0x70,
0xCA, 0xC4, 0xD6, 0xD8, 0xF2, 0xFC, 0xEE, 0xE0, 0xBA, 0xB4, 0xA6, 0xA8, 0x82, 0x8C, 0x9E, 0x90,
0xE4, 0xEA, 0xF8, 0xF6, 0xDC, 0xD2, 0xC0, 0xCE, 0x94, 0x9A, 0x88, 0x86, 0xAC, 0xA2, 0xB0, 0xBE,
0x04, 0x0A, 0x18, 0x16, 0x3C, 0x32, 0x20, 0x2E, 0x74, 0x7A, 0x68, 0x66, 0x4C, 0x42, 0x50, 0x5E,
0xB8, 0xB6, 0xA4, 0xAA, 0x80, 0x8E, 0x9C, 0x92, 0xC8, 0xC6, 0xD4, 0xDA, 0xF0, 0xFE, 0xEC, 0xE2,
0x58, 0x56, 0x44, 0x4A, 0x60, 0x6E, 0x7C, 0x72, 0x28, 0x26, 0x34, 0x3A, 0x10, 0x1E, 0x0C, 0x02,
0x76, 0x78, 0x6A, 0x64, 0x4E, 0x40, 0x52, 0x5C, 0x06, 0x08, 0x1A, 0x14, 0x3E, 0x30, 0x22, 0x2C,
0x96, 0x98, 0x8A, 0x84, 0xAE, 0xA0, 0xB2, 0xBC, 0xE6, 0xE8, 0xFA, 0xF4, 0xDE, 0xD0, 0xC2, 0xCC};

const char Table95[]={
0x00, 0x2A, 0x54, 0x7E, 0xA8, 0x82, 0xFC, 0xD6, 0x7A, 0x50, 0x2E, 0x04, 0xD2, 0xF8, 0x86, 0xAC,
0xF4, 0xDE, 0xA0, 0x8A, 0x5C, 0x76, 0x08, 0x22, 0x8E, 0xA4, 0xDA, 0xF0, 0x26, 0x0C, 0x72, 0x58,
0xC2, 0xE8, 0x96, 0xBC, 0x6A, 0x40, 0x3E, 0x14, 0xB8, 0x92, 0xEC, 0xC6, 0x10, 0x3A, 0x44, 0x6E,
0x36, 0x1C, 0x62, 0x48, 0x9E, 0xB4, 0xCA, 0xE0, 0x4C, 0x66, 0x18, 0x32, 0xE4, 0xCE, 0xB0, 0x9A,
0xAE, 0x84, 0xFA, 0xD0, 0x06, 0x2C, 0x52, 0x78, 0xD4, 0xFE, 0x80, 0xAA, 0x7C, 0x56, 0x28, 0x02,
0x5A, 0x70, 0x0E, 0x24, 0xF2, 0xD8, 0xA6, 0x8C, 0x20, 0x0A, 0x74, 0x5E, 0x88, 0xA2, 0xDC, 0xF6,
0x6C, 0x46, 0x38, 0x12, 0xC4, 0xEE, 0x90, 0xBA, 0x16, 0x3C, 0x42, 0x68, 0xBE, 0x94, 0xEA, 0xC0,
0x98, 0xB2, 0xCC, 0xE6, 0x30, 0x1A, 0x64, 0x4E, 0xE2, 0xC8, 0xB6, 0x9C, 0x4A, 0x60, 0x1E, 0x34,
0x76, 0x5C, 0x22, 0x08, 0xDE, 0xF4, 0x8A, 0xA0, 0x0C, 0x26, 0x58, 0x72, 0xA4, 0x8E, 0xF0, 0xDA,
0x82, 0xA8, 0xD6, 0xFC, 0x2A, 0x00, 0x7E, 0x54, 0xF8, 0xD2, 0xAC, 0x86, 0x50, 0x7A, 0x04, 0x2E,
0xB4, 0x9E, 0xE0, 0xCA, 0x1C, 0x36, 0x48, 0x62, 0xCE, 0xE4, 0x9A, 0xB0, 0x66, 0x4C, 0x32, 0x18,
0x40, 0x6A, 0x14, 0x3E, 0xE8, 0xC2, 0xBC, 0x96, 0x3A, 0x10, 0x6E, 0x44, 0x92, 0xB8, 0xC6, 0xEC, 
0xD8, 0xF2, 0x8C, 0xA6, 0x70, 0x5A, 0x24, 0x0E, 0xA2, 0x88, 0xF6, 0xDC, 0x0A, 0x20, 0x5E, 0x74, 
0x2C, 0x06, 0x78, 0x52, 0x84, 0xAE, 0xD0, 0xFA, 0x56, 0x7C, 0x02, 0x28, 0xFE, 0xD4, 0xAA, 0x80, 
0x1A, 0x30, 0x4E, 0x64, 0xB2, 0x98, 0xE6, 0xCC, 0x60, 0x4A, 0x34, 0x1E, 0xC8, 0xE2, 0x9C, 0xB6, 
0xEE, 0xC4, 0xBA, 0x90, 0x46, 0x6C, 0x12, 0x38, 0x94, 0xBE, 0xC0, 0xEA, 0x3C, 0x16, 0x68, 0x42};



void stm32_Usart1Setup (long baudrate) 
{
RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;                     // enable clock for Alternate Function
AFIO->MAPR   &= ~(1 << 2);                              // clear USART1 remap
RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;                   // enable clock for GPIOA
GPIOA->CRH   &= ~(0xFFUL  << 4);                      // Clear PA9, PA10
GPIOA->CRH   |=  (0x0BUL  << 4);                      // USART1 Tx (PA9)  alternate output push-pull
GPIOA->CRH   |=  (0x04UL  << 8);                      // USART1 Rx (PA10) input floating

RCC->APB2ENR |= RCC_APB2ENR_USART1EN;                   // enable clock for USART1
        
USART1->BRR  = __USART_BRR(__PCLK2, baudrate); // set baudrate
USART1->CR1  = 0;                       // set Data bits
USART1->CR2  = 0;                       // set Stop bits
USART1->CR1 |= 0;                         // set Parity
USART1->CR3  = 0;                       // Set Flow Control

USART1->CR1 |= (USART_CR1_RE | USART_CR1_TE);           // RX, TX enable

USART1->CR1 |= 0x000000E0;
USART1->CR2 |= 0x00000000;
USART1->CR3 |= 0x00000000;
NVIC->ISER[1]  = (1 << (USART1_IRQChannel & 0x1F));   // enable interrupt


USART1->CR1 |= USART_CR1_UE;                            // USART enable
} // end USART1 used




//-----------------------------------------------
char crc_87(char* ptr,char num)
{
char r,j;
r=*ptr;

for(j=1;j<num;j++)
	{
     ptr++;
	r=((*ptr)^Table87[r]);
	}

return r;	
} 

//-----------------------------------------------
char crc_95(char* ptr,char num)
{
char r,j;
r=*ptr;

for(j=1;j<num;j++)
	{
     ptr++;
	r=((*ptr)^Table95[r]);
	}

return r;	
}

//-----------------------------------------------
void putchar1(char c)
{
short i;
while (tx_counter1 == TX_BUFFER_SIZE1);

tx_buffer1[tx_wr_index1]=c;
bTRANSMIT1=TRUE;   
if (++tx_wr_index1 >= TX_BUFFER_SIZE1) tx_wr_index1=0;


if (tx1_restart) 
	{                               // If transmit interrupt is disabled, enable it
    tx1_restart = 0;
	GPIOA->ODR|=(1<<11);
	for(i=1000;i>0;i--) __nop();
	USART1->CR1 |= USART_FLAG_TXE;		          // enable TX interrupt
	
//	plazma_debug_0=c;
//	plazma_debug_1=1;


  	}
}

//-----------------------------------------------
void uart_out1 (char num,char data0,char data1,char data2,char data3,char data4,char data5)
{
char i,t=0;
//char *ptr=&data1;
char UOB1[16]; 
UOB1[0]=data0;
UOB1[1]=data1;
UOB1[2]=data2;
UOB1[3]=data3;
UOB1[4]=data4;
UOB1[5]=data5;

for (i=0;i<num;i++)
	{
	t^=UOB1[i];
	}    
UOB1[num]=num;
t^=UOB1[num];
UOB1[num+1]=t;
UOB1[num+2]=0x0a;

for (i=0;i<num+3;i++)
	{
	putchar1(UOB1[i]);
	}   	
}

//-----------------------------------------------
//-----------------------------------------------
//-----------------------------------------------
//-----------------------------------------------
void USART1_IRQHandler (void) 
{
volatile unsigned int IIR;
//struct buf_st *p;
char data;

IIR = USART1->SR;		
if (IIR & USART_FLAG_RXNE) 
	{                  	
	USART1->SR &= ~USART_FLAG_RXNE;	          // clear interrupt

	plazma_uart1[0]++;

	data=USART1->DR & 0x00ff;
	if(bTRANSMIT1==0) 
		{
		/*rx_buffer1[rx_wr_index1]=data;
   		bRXIN1=1;
   		if (++rx_wr_index1 == RX_BUFFER_SIZE1) rx_wr_index1=0;
   		if (++rx_counter1 == RX_BUFFER_SIZE1)
      		{
      		rx_counter1=0;
      		rx_buffer_overflow1=1;
      		}*/
		modbus_rx_buffer[modbus_rx_buffer_ptr]=data;
		modbus_rx_buffer_ptr++;
		modbus_timeout_cnt=10;
		}
	
    }

if (IIR & USART_FLAG_TXE) 
	{
 	USART1->SR &= ~USART_FLAG_TXE;	          // clear interrupt
	//GPIOB->ODR^=(1<<12);
	if (tx_rd_index1 != tx_wr_index1)
		{
   		USART1->DR = tx_buffer1[tx_rd_index1];
		
		if (++tx_rd_index1 >= TX_BUFFER_SIZE1) tx_rd_index1=0;
   		}
	else 
	 	{
		tx1_restart = 1;
		USART1->CR1 &= ~USART_FLAG_TXE;		      // disable TX interrupt if nothing to send
		}
   	}

if (IIR & USART_FLAG_TC) 
	{
 	USART1->SR &= ~USART_FLAG_TC;	          // clear interrupt
	//GPIOC->ODR^=(1<<6);
	bTRANSMIT1=FALSE;
	GPIOA->ODR&=~(1<<11);

   	}
}

